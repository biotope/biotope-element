---
name: 1 Basics
route: '/basics'
---

# Basics



## The concept of a component

We trust in the web. That's why we decided to write biotope and the biotope element with mostly vanilla web technologies and polyfill it untill the right time is there.
On of these fancy new technologies is web components and all the proposals belonging to it (shadow dom, custom elements, scoped styling).
  
Biotope element is just an extension of the vanilla html element which add some nice features.
  
So everything you build using the biotope element will be called a component in the following documentation.
  
A component is a collection of functionality which could be reused.












## Hello world
First import the element in your component:
```js
import Element from '@biotope/element';
```

Then you extend your component with the biotope element:
```js
class MyButton extends Element {
    static componentName = 'my-button';
    
    render() {
        return this.html`Hello World üê§`;
    }
}
```
> Notice the `static componentName` part. This has to be set AND there needs to ba a dash in there.

After defining the class, you have to call the `register` function on it, to use it in HTML:
```js
MyButton.register();
```

So the whole file will look like this:
```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    render() {
        return this.html`Hello World üê§`;
    }
}

MyButton.register();
```

After that you can use it in your html like that:
```html 
<my-button></my-button>
```

This will result inthe following html:
```html
<my-button>
    Hello world üê§
</my-button>
```






## Render
As you can see in the hello world example every component implements a `render` function. In there you can call `this.html` function on a template literal to add it to the components root:

```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    render() {
        // this will add 'Hello World' to the root of the element
        return this.html`Hello World üê§`;
    }
}

MyButton.register();
```

In the template literal you can also add valid html code as well as the `<slot>` tag where the current content of the component will be placed. Read more about it in the [shadow dom](#shadow-dom) section.








### Styling
As every component uses shadow dom by default, you have to put the styles inside the shadow root. You can either write inline styles:
```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    render() {
        return this.html`
        <style>
            :host {
                background-color: orange;
            }
        </style>
        Hello World üê§
        `;
    }
}

MyButton.register();
```

or import your css from an external file with some kind of bundler:
```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    render() {
        return this.html`
        <style>
            ${require('./styles.css').toString()}
        </style>
        Hello World üê§
        `;
    }
}

MyButton.register();
```





## Props
Every component has its own props. The props can be passed into the component two ways:

You can use attributes or set the props via javascript:


### Default props
To give your props a default value you have to set the `defaultProps` getter of the component:
```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    protected get defaultProps(): {
        return {
            foo: 'bar'
        }
    }
    
    render() {
        return this.html`üé∞ ${this.props.foo}`;
    }
}

MyButton.register();
```
```html
<my-button></my-button>
```

This will result in the following html:

```html
<my-button>üé∞ bar</my-button>
```



### Setting props
You can set the props of a component after initialisation by accessing its instance like this:
```html
<my-button id="foo"></my-button>
```
```js
document.getElementById('foo').props = {
    foo: 'bar'
}
```
Changing the props this way will trigger its `onPropsChanged` function, which will automatically call the render method.





### Using attributes
To pass in data to a component attributes on the html tag can be used:
```html
<my-button foo="bar"><my-button>
```

To pass these values to the props object, you have to define the corresponding attribute in the component:
```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    static attributes = ['foo'];
    
    render() {
        return this.html`üå∏`;
    }
}

MyButton.register();
```

This will take care of the attributes value and pass it to the props of the component:

```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    static attributes = ['foo'];

    render() {
        return this.html`${this.props.foo} üå∏`;
    }
}

MyButton.register();
```

This will result in the following html:
```html
<my-button foo="bar">
    bar üå∏
<my-button>
```

### Hyphen Attributes
If your attributes get more complex, you might want to have multi word names like `a-complex-attribute`.

To access those attributes in the props, you have to use the camelCase version of the string. In our example this will be `aComplexAttribute`

```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    static attributes = ['another-attribute'];

    render() {
        return this.html`${this.props.anotherAttribute} üå∏`;
    }
}

MyButton.register();
```

This will result in the following html:
```html
<my-button another-attribute="Some simple value">
    Some simple value üå∏
<my-button>
```










### Transforming attributes
When you set values in the html tags attributes, these values will always be strings. If you pass other data types through the attributes, you also have to take care of their transformation. You can do this by setting a attribute converter in the attributes array instead of a simple string:

```html
<my-button fooNum="5"><my-button>
```
```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    // here we use the converter config
    static attributes = [{name: 'fooNum', converter: (value) => parseInt(value, 10)}];
    
    render() {
        // foo will now be a number
        return this.html`üöÄ ${typeof this.props.fooNum}`;
    }
}

MyButton.register();
```
This will result in the following html:
```html
<my-button fooNum="5">
    üöÄ number
<my-button>
```

> Note: You can get a list of the observed attributes by using the components `this.observedAttributes` property

## Shadow dom
Every component extending the biotope element is using shadow dom. This will help you to not mess up our existing component structure.
If have the following html and js:

```html
<my-button>
    I am a little ü¶ã
<my-button>
```
```js
import Element from '@biotope/element';

class MyButton extends Element {
    static componentName = 'my-button';
    
    render() {
        // the slot will be replaced by the current content
        return this.html`
            <slot/>
            <span>I am a little üêõ</span>
        `;
    }
}

MyButton.register();
```

It would result in this html:
```html
<my-button>
    I am a little ü¶ã
    <span>I am a little üêõ</span>
<my-button>
```
